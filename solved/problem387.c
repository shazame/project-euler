/*******************************
 * Site: Project Euler
 * Link: http://projecteuler.net/problems
 * Problem:
 * A Harshad or Niven number is a number that is divisible by the sum of its digits.
 * 201 is a Harshad number because it is divisible by 3 (the sum of its digits.)
 * When we truncate the last digit from 201, we get 20, which is a Harshad number.
 * When we truncate the last digit from 20, we get 2, which is also a Harshad number.
 * Let's call a Harshad number that, while recursively truncating the last digit, always results in a Harshad number a right truncatable Harshad number.
 * 
 * Also:
 * 201/3=67 which is prime.
 * Let's call a Harshad number that, when divided by the sum of its digits, results in a prime a strong Harshad number.
 * 
 * Now take the number 2011 which is prime.
 * When we truncate the last digit from it we get 201, a strong Harshad number that is also right truncatable.
 * Let's call such primes strong, right truncatable Harshad primes.
 * 
 * You are given that the sum of the strong, right truncatable Harshad primes less than 10000 is 90619.
 * 
 * Find the sum of the strong, right truncatable Harshad primes less than 10^14.
 * 
 * Solution by: David
 * Answer: 696067597313468 
 *
 * Comment:
 *******************************/

#include <stdio.h>
#include <assert.h>

#define MAX_SIZE 100000

typedef unsigned long long int harshad_t;

harshad_t sum_digits(harshad_t n){
	harshad_t s = 0;

	for (; n > 0; n/=10){
		s += (harshad_t)n%10;
	}

	return s;
}

int is_harshad(harshad_t n){
	return (n % sum_digits(n)) == 0;
}

void list_harshad_number_below(harshad_t n){
	harshad_t i = 1;

	for (; i <= n; i++){
		if (is_harshad(i)){
			printf("%lld\n", i);
		}
	}
}

/* This function takes a right truncatable Harshad number (RTHN) n,
 * an array T, its size s and a pointer to an index i.
 * It adds to the array, from the index, the lists of right
 * truncatable Harshad numbers that result in n when their
 * last digit is truncated.
 * Returns the last RTHN of the list.
 *
 * For example: with n=20, the numbers 200, 201, 204, 207
 * and 209 would be added to the array.
 * 209 would be returned.
 */
harshad_t add_list_RTHN(harshad_t n, harshad_t T[], size_t s, size_t * i){
	harshad_t k = 0;

	assert(*i + 10 < s);

	for (; k < 10; k++){
		if (is_harshad(n*10+k)){
			T[(*i)++] = n*10+k;
		}
	}

	return T[*i - 1];
}

size_t list_RTHN_number_below(harshad_t n, harshad_t T[], size_t s){
	size_t i = 0;
	int index = 0;

	for (; i < 9; i++){
		T[i] = i+1;
	}

	while (add_list_RTHN(T[index], T, s, &i) < n){
		index++;
	}

	return i;
}

int is_prime(harshad_t n){
	harshad_t i = 2;

	if (n == 1)
		return 0;

	for (; i*i <= n; i++){
		if (0 == (n%i)){
			return 0;
		}
	}

	return 1;
}

int is_strong_H(harshad_t n) {
	return is_prime(n/sum_digits(n));	
}

/* This function takes an array containing RTHN, his size
 * and an empty array with the same size.
 * It fills the empty array with the elements of the other
 * array that are also strong Harshad numbers.
 *
 * The size of the new filled array is returned.
 */
size_t filter_strong_RTHN(harshad_t T[], size_t n, harshad_t S[]){
	size_t i = 0, s = 0;

	for (; i < n; i++) {
		if (is_strong_H(T[i])){
			S[s++] = T[i];
		}
	}

	return s;
}

/* This function takes a strong, right truncatable Harshad number (SRTHN) n,
 * an array P, its size s and a pointer to an index i.
 * It adds to the array, from the index, the lists of prime numbers
 * that result in n when their last digit is truncated.
 * Returns the last prime number of the list.
 */
harshad_t add_list_SRTHP(harshad_t n, harshad_t P[], size_t s, size_t * i){
	int k = 0;

	for (; k < 10; k++){
		if (is_prime(n*10+k)){
			P[(*i)++] = n*10+k;
		}
	}

	return P[*i - 1];
}

/* This function takes an array containing SRTHN, his size
 * and an empty array with the same size.
 * It fills the empty array with the set of prime numbers
 * generated by the elements of the other array.
 *
 * The size of the new filled array is returned.
 */
size_t list_SRTHP(harshad_t S[], size_t n, harshad_t P[]){
	size_t i = 0, index = 0;

	for (; i < n; i++){
		add_list_SRTHP(S[i], P, n, &index);
	}

	return index;
}

harshad_t sum_below(harshad_t T[], size_t n, harshad_t max){
	size_t i = 0;
	harshad_t sum = 0;

	for (; (i < n) && (T[i] <= max); i++){
		sum += T[i];
	}

	return sum;
}

int main(void){
	//list_harshad_number_below(1000000);

	harshad_t T[MAX_SIZE] = {0};
	harshad_t S[MAX_SIZE] = {0};
	harshad_t P[MAX_SIZE] = {0};

	harshad_t go_until = 100000000000000;
	printf("go until: %lld\n", go_until);

	size_t i = list_RTHN_number_below(go_until, T, MAX_SIZE);
	printf("number of RTHN: %d\n", i);

	size_t j = filter_strong_RTHN(T, i, S);
	printf("number of SRTHN: %d\n", j);

	size_t l = list_SRTHP(S, j, P);
	printf("number of SRTHP: %d\n", l);

	printf("sum of SRTHP less than %lld: %lld\n", go_until, sum_below(P, l, go_until));

	/*
	size_t k;

	for (k = 0; k <= l; k++){
		printf("%lld\n", P[k]);
	}
	/**/

	return 0;
}
